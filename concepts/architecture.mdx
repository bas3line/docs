---
title: 'Architecture'
description: 'How UltraBalancer works'
---

## How It Works

```
Client → UltraBalancer → Backend Servers
              ↓
         Health Checks
              ↓
         Metrics (Prometheus)
```

## Core Components

| Component | Description |
|-----------|-------------|
| **Proxy Server** | Accepts requests, routes to backends |
| **Load Balancer** | Algorithm for backend selection |
| **Backend Pool** | Manages server list and health |
| **Health Checker** | Monitors backend availability |
| **Metrics** | Tracks performance data |

## Request Flow

1. Client sends request to UltraBalancer
2. Rate limiting check (if enabled)
3. Select backend using algorithm
4. Proxy request to backend
5. Stream response back to client
6. Record metrics

## Algorithms

- **Round Robin** - Equal distribution
- **Least Connections** - Fewest active connections
- **IP Hash** - Consistent client-to-backend mapping
- **Weighted** - Based on backend weight
- **Random** - Random selection
- **Power of Two** - Pick 2, use least loaded
- **Fastest Response** - Lowest latency backend

## Data Flow

```
HTTP Request
    ↓
Parse Request
    ↓
Extract Client IP
    ↓
Check Rate Limit
    ↓
Select Backend (algorithm)
    ↓
Proxy to Backend
    ↓
Stream Response
    ↓
Update Metrics
```

## Tech Stack

- **Runtime**: Tokio (async)
- **HTTP**: Hyper
- **TLS**: Rustls
- **Serialization**: Serde

## Related

- [Algorithms](/concepts/algorithms) - Selection strategies
- [Health Checks](/concepts/health-checks) - Backend monitoring
- [Metrics](/concepts/metrics) - Observability